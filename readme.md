# CSCI 2275 â€“ Data Structures - Final Project
Contributors:
Henry Miller,
Nathan Khazam

Our program is essentially a miniature version of how Git and GitHub work. When the user runs and initializes the program, a doubly linked list BranchNode is created, where the user can work by adding and removing files. Each file they add is a singly linked list FileNode that the BranchNode keeps track of by assigning a head pointer to the start of the FileNodes. A hashtable is also created which will hold the commit messages when the user eventually decides to commit. For the options that the user has, they can either (1) initialize the project, (2) add a file, (3) remove a file that they previously added, (4) commit their files so that they are saved and uploaded to minigit, (5) checkout previous commits to see what they had previously saved, (6) search the hashtable for previous committed messages to return what ID's those messages are on, or (7) quit the program.

For specific functions, adding will take a filename from the user and put it in a FileNode that connects to the current BranchNode along with what version of the file it is. For removing, this process is basically reversed, the FileNode is just deleted from the linked list. For committing, the BranchNode and the FileNodes attached to it are locked, the files are uploaded to the minigit directory, and the FileNodes are deep copied to a new BranchNode. For checkout, the user is asked for a previous commit number they want to visit, and then the files will be replaced for the version of the commit. During a checkout of a previous commit, you cannot add, remove, or commit the files, because they have already been saved and locked. For searching, the user provides a key and and then the hashtable is searched through for the specific key, and if it finds the key then it prints the commitIDs where that key was used.